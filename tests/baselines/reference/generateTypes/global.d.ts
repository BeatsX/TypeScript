export class Array {
    static from(p0: any): any;
    static isArray(p0: any): any;
    static of(): any;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    concat(p0: any): any;
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    pop(): any;
    // Native method; no parameter or return type inference available
    push(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    shift(): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    splice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    unshift(p0: any): any;
}
export class ArrayBuffer {
    static isView(p0: any): any;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
}
export namespace Atomics {
    function add(p0: any, p1: any, p2: any): any;
    function and(p0: any, p1: any, p2: any): any;
    function compareExchange(p0: any, p1: any, p2: any, p3: any): any;
    function exchange(p0: any, p1: any, p2: any): any;
    function isLockFree(p0: any): any;
    function load(p0: any, p1: any): any;
    function or(p0: any, p1: any, p2: any): any;
    function store(p0: any, p1: any, p2: any): any;
    function sub(p0: any, p1: any, p2: any): any;
    function wait(p0: any, p1: any, p2: any, p3: any): any;
    function wake(p0: any, p1: any, p2: any): any;
    function xor(p0: any, p1: any, p2: any): any;
}
export class BigInt {
    static asIntN(p0: any, p1: any): any;
    static asUintN(p0: any, p1: any): any;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    valueOf(): any;
}
export class BigInt64Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class BigUint64Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class Boolean {
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    valueOf(): any;
}
export class Buffer {
    static BYTES_PER_ELEMENT: number;
    static alloc(size: any, fill: any, encoding: any): any;
    static allocUnsafe(size: any): any;
    static allocUnsafeSlow(size: any): any;
    static byteLength(string: any, encoding: any): any;
    static compare(buf1: any, buf2: any): any;
    static concat(list: any, length: any): any;
    static from(value: any, encodingOrOffset: any, length: any): any;
    static isBuffer(b: any): any;
    static isEncoding(encoding: any): any;
    static of(items: any): any;
    static poolSize: number;
    constructor(arg: any, encodingOrOffset: any, length: any);
    // Native method; no parameter or return type inference available
    asciiSlice(): any;
    // Native method; no parameter or return type inference available
    asciiWrite(): any;
    // Native method; no parameter or return type inference available
    base64Slice(): any;
    // Native method; no parameter or return type inference available
    base64Write(): any;
    compare(target: any, start: any, end: any, thisStart: any, thisEnd: any): any;
    copy(target: any, targetStart: any, sourceStart: any, sourceEnd: any): any;
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    equals(otherBuffer: any): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    fill(val: any, start: any, end: any, encoding: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    hexSlice(): any;
    // Native method; no parameter or return type inference available
    hexWrite(): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    inspect(): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    latin1Slice(): any;
    // Native method; no parameter or return type inference available
    latin1Write(): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    readDoubleBE(offset: any): any;
    readDoubleLE(offset: any): any;
    readFloatBE(offset: any): any;
    readFloatLE(offset: any): any;
    readInt16BE(offset: any): any;
    readInt16LE(offset: any): any;
    readInt32BE(offset: any): any;
    readInt32LE(offset: any): any;
    readInt8(offset: any): any;
    readIntBE(offset: any, byteLength: any): any;
    readIntLE(offset: any, byteLength: any): any;
    readUInt16BE(offset: any): any;
    readUInt16LE(offset: any): any;
    readUInt32BE(offset: any): any;
    readUInt32LE(offset: any): any;
    readUInt8(offset: any): any;
    readUIntBE(offset: any, byteLength: any): any;
    readUIntLE(offset: any, byteLength: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    slice(start: any, end: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    swap16(): any;
    swap32(): any;
    swap64(): any;
    toJSON(): void;
    toLocaleString(encoding: any, start: any, end: any): any;
    toString(encoding: any, start: any, end: any): any;
    // Native method; no parameter or return type inference available
    ucs2Slice(): any;
    // Native method; no parameter or return type inference available
    ucs2Write(): any;
    // Native method; no parameter or return type inference available
    utf8Slice(): any;
    // Native method; no parameter or return type inference available
    utf8Write(): any;
    // Native method; no parameter or return type inference available
    values(): any;
    write(string: any, offset: any, length: any, encoding: any): any;
    writeDoubleBE(val: any, offset: any): any;
    writeDoubleLE(val: any, offset: any): any;
    writeFloatBE(val: any, offset: any): any;
    writeFloatLE(val: any, offset: any): any;
    writeInt16BE(value: any, offset: any): any;
    writeInt16LE(value: any, offset: any): any;
    writeInt32BE(value: any, offset: any): any;
    writeInt32LE(value: any, offset: any): any;
    writeInt8(value: any, offset: any): any;
    writeIntBE(value: any, offset: any, byteLength: any): any;
    writeIntLE(value: any, offset: any, byteLength: any): any;
    writeUInt16BE(value: any, offset: any): any;
    writeUInt16LE(value: any, offset: any): any;
    writeUInt32BE(value: any, offset: any): any;
    writeUInt32LE(value: any, offset: any): any;
    writeUInt8(value: any, offset: any): any;
    writeUIntBE(value: any, offset: any, byteLength: any): any;
    writeUIntLE(value: any, offset: any, byteLength: any): any;
}
export class DataView {
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    getBigInt64(p0: any): any;
    // Native method; no parameter or return type inference available
    getBigUint64(p0: any): any;
    // Native method; no parameter or return type inference available
    getFloat32(p0: any): any;
    // Native method; no parameter or return type inference available
    getFloat64(p0: any): any;
    // Native method; no parameter or return type inference available
    getInt16(p0: any): any;
    // Native method; no parameter or return type inference available
    getInt32(p0: any): any;
    // Native method; no parameter or return type inference available
    getInt8(p0: any): any;
    // Native method; no parameter or return type inference available
    getUint16(p0: any): any;
    // Native method; no parameter or return type inference available
    getUint32(p0: any): any;
    // Native method; no parameter or return type inference available
    getUint8(p0: any): any;
    // Native method; no parameter or return type inference available
    setBigInt64(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setBigUint64(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setFloat32(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setFloat64(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setInt16(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setInt32(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setInt8(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setUint16(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setUint32(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setUint8(p0: any, p1: any): any;
}
export class Date {
    static UTC(p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any): any;
    static now(): any;
    static parse(p0: any): any;
    constructor(p0: any, p1: any, p2: any, p3: any, p4: any, p5: any, p6: any);
    // Native method; no parameter or return type inference available
    getDate(): any;
    // Native method; no parameter or return type inference available
    getDay(): any;
    // Native method; no parameter or return type inference available
    getFullYear(): any;
    // Native method; no parameter or return type inference available
    getHours(): any;
    // Native method; no parameter or return type inference available
    getMilliseconds(): any;
    // Native method; no parameter or return type inference available
    getMinutes(): any;
    // Native method; no parameter or return type inference available
    getMonth(): any;
    // Native method; no parameter or return type inference available
    getSeconds(): any;
    // Native method; no parameter or return type inference available
    getTime(): any;
    // Native method; no parameter or return type inference available
    getTimezoneOffset(): any;
    // Native method; no parameter or return type inference available
    getUTCDate(): any;
    // Native method; no parameter or return type inference available
    getUTCDay(): any;
    // Native method; no parameter or return type inference available
    getUTCFullYear(): any;
    // Native method; no parameter or return type inference available
    getUTCHours(): any;
    // Native method; no parameter or return type inference available
    getUTCMilliseconds(): any;
    // Native method; no parameter or return type inference available
    getUTCMinutes(): any;
    // Native method; no parameter or return type inference available
    getUTCMonth(): any;
    // Native method; no parameter or return type inference available
    getUTCSeconds(): any;
    // Native method; no parameter or return type inference available
    getYear(): any;
    // Native method; no parameter or return type inference available
    setDate(p0: any): any;
    // Native method; no parameter or return type inference available
    setFullYear(p0: any, p1: any, p2: any): any;
    // Native method; no parameter or return type inference available
    setHours(p0: any, p1: any, p2: any, p3: any): any;
    // Native method; no parameter or return type inference available
    setMilliseconds(p0: any): any;
    // Native method; no parameter or return type inference available
    setMinutes(p0: any, p1: any, p2: any): any;
    // Native method; no parameter or return type inference available
    setMonth(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setSeconds(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setTime(p0: any): any;
    // Native method; no parameter or return type inference available
    setUTCDate(p0: any): any;
    // Native method; no parameter or return type inference available
    setUTCFullYear(p0: any, p1: any, p2: any): any;
    // Native method; no parameter or return type inference available
    setUTCHours(p0: any, p1: any, p2: any, p3: any): any;
    // Native method; no parameter or return type inference available
    setUTCMilliseconds(p0: any): any;
    // Native method; no parameter or return type inference available
    setUTCMinutes(p0: any, p1: any, p2: any): any;
    // Native method; no parameter or return type inference available
    setUTCMonth(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setUTCSeconds(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    setYear(p0: any): any;
    // Native method; no parameter or return type inference available
    toDateString(): any;
    // Native method; no parameter or return type inference available
    toGMTString(): any;
    // Native method; no parameter or return type inference available
    toISOString(): any;
    // Native method; no parameter or return type inference available
    toJSON(p0: any): any;
    // Native method; no parameter or return type inference available
    toLocaleDateString(): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toLocaleTimeString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    toTimeString(): any;
    // Native method; no parameter or return type inference available
    toUTCString(): any;
    // Native method; no parameter or return type inference available
    valueOf(): any;
}
export class Error {
    static captureStackTrace(p0: any, p1: any): any;
    static prepareStackTrace(error: any, stack: any): any;
    static stackTraceLimit: number;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
}
export class EvalError {
    static captureStackTrace(p0: any, p1: any): any;
    static prepareStackTrace(error: any, stack: any): any;
    static stackTraceLimit: number;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
}
export class Float32Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class Float64Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export function Function(p0: any): any;
export const GLOBAL: any;
export const Infinity: number;
export class Int16Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class Int32Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class Int8Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export namespace Intl {
    class Collator {
        static supportedLocalesOf(p0: any): any;
        // Native method; no parameter or return type inference available
        resolvedOptions(): any;
    }
    class DateTimeFormat {
        static supportedLocalesOf(p0: any): any;
        // Native method; no parameter or return type inference available
        formatToParts(p0: any): any;
        // Native method; no parameter or return type inference available
        resolvedOptions(): any;
    }
    class NumberFormat {
        static supportedLocalesOf(p0: any): any;
        // Native method; no parameter or return type inference available
        formatToParts(p0: any): any;
        // Native method; no parameter or return type inference available
        resolvedOptions(): any;
    }
    class PluralRules {
        static supportedLocalesOf(p0: any): any;
        // Native method; no parameter or return type inference available
        resolvedOptions(): any;
        // Native method; no parameter or return type inference available
        select(p0: any): any;
    }
    function getCanonicalLocales(p0: any): any;
}
export namespace JSON {
    function parse(p0: any, p1: any): any;
    function stringify(p0: any, p1: any, p2: any): any;
}
export class Map {
    // Native method; no parameter or return type inference available
    clear(): any;
    // Native method; no parameter or return type inference available
    delete(p0: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    get(p0: any): any;
    // Native method; no parameter or return type inference available
    has(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    set(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export namespace Math {
    const E: number;
    const LN10: number;
    const LN2: number;
    const LOG10E: number;
    const LOG2E: number;
    const PI: number;
    const SQRT1_2: number;
    const SQRT2: number;
    function abs(p0: any): any;
    function acos(p0: any): any;
    function acosh(p0: any): any;
    function asin(p0: any): any;
    function asinh(p0: any): any;
    function atan(p0: any): any;
    function atan2(p0: any, p1: any): any;
    function atanh(p0: any): any;
    function cbrt(p0: any): any;
    function ceil(p0: any): any;
    function clz32(p0: any): any;
    function cos(p0: any): any;
    function cosh(p0: any): any;
    function exp(p0: any): any;
    function expm1(p0: any): any;
    function floor(p0: any): any;
    function fround(p0: any): any;
    function hypot(p0: any, p1: any): any;
    function imul(p0: any, p1: any): any;
    function log(p0: any): any;
    function log10(p0: any): any;
    function log1p(p0: any): any;
    function log2(p0: any): any;
    function max(p0: any, p1: any): any;
    function min(p0: any, p1: any): any;
    function pow(p0: any, p1: any): any;
    function random(): any;
    function round(p0: any): any;
    function sign(p0: any): any;
    function sin(p0: any): any;
    function sinh(p0: any): any;
    function sqrt(p0: any): any;
    function tan(p0: any): any;
    function tanh(p0: any): any;
    function trunc(p0: any): any;
}
export const NaN: number;
export class Number {
    static EPSILON: number;
    static MAX_SAFE_INTEGER: number;
    static MAX_VALUE: number;
    static MIN_SAFE_INTEGER: number;
    static MIN_VALUE: number;
    static NEGATIVE_INFINITY: number;
    static NaN: number;
    static POSITIVE_INFINITY: number;
    static isFinite(p0: any): any;
    static isInteger(p0: any): any;
    static isNaN(p0: any): any;
    static isSafeInteger(p0: any): any;
    static parseFloat(p0: any): any;
    static parseInt(p0: any, p1: any): any;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toExponential(p0: any): any;
    // Native method; no parameter or return type inference available
    toFixed(p0: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toPrecision(p0: any): any;
    // Native method; no parameter or return type inference available
    toString(p0: any): any;
    // Native method; no parameter or return type inference available
    valueOf(): any;
}
export function Object(p0: any): any;
export namespace Object {
    function assign(p0: any, p1: any): any;
    function create(p0: any, p1: any): any;
    function defineProperties(p0: any, p1: any): any;
    function defineProperty(p0: any, p1: any, p2: any): any;
    function entries(p0: any): any;
    function freeze(p0: any): any;
    function getOwnPropertyDescriptor(p0: any, p1: any): any;
    function getOwnPropertyDescriptors(p0: any): any;
    function getOwnPropertyNames(p0: any): any;
    function getOwnPropertySymbols(p0: any): any;
    function getPrototypeOf(p0: any): any;
    function is(p0: any, p1: any): any;
    function isExtensible(p0: any): any;
    function isFrozen(p0: any): any;
    function isSealed(p0: any): any;
    function keys(p0: any): any;
    function preventExtensions(p0: any): any;
    function seal(p0: any): any;
    function setPrototypeOf(p0: any, p1: any): any;
    function values(p0: any): any;
}
export class Promise {
    static all(p0: any): any;
    static race(p0: any): any;
    static reject(p0: any): any;
    static resolve(p0: any): any;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    catch(p0: any): any;
    // Native method; no parameter or return type inference available
    finally(p0: any): any;
    // Native method; no parameter or return type inference available
    then(p0: any, p1: any): any;
}
export function Proxy(p0: any, p1: any): any;
export namespace Proxy {
    function revocable(p0: any, p1: any): any;
}
export class RangeError {
    static captureStackTrace(p0: any, p1: any): any;
    static prepareStackTrace(error: any, stack: any): any;
    static stackTraceLimit: number;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
}
export class ReferenceError {
    static captureStackTrace(p0: any, p1: any): any;
    static prepareStackTrace(error: any, stack: any): any;
    static stackTraceLimit: number;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
}
export namespace Reflect {
    function apply(p0: any, p1: any, p2: any): any;
    function construct(p0: any, p1: any): any;
    function defineProperty(p0: any, p1: any, p2: any): any;
    function deleteProperty(p0: any, p1: any): any;
    function get(p0: any, p1: any): any;
    function getOwnPropertyDescriptor(p0: any, p1: any): any;
    function getPrototypeOf(p0: any): any;
    function has(p0: any, p1: any): any;
    function isExtensible(p0: any): any;
    function ownKeys(p0: any): any;
    function preventExtensions(p0: any): any;
    function set(p0: any, p1: any, p2: any): any;
    function setPrototypeOf(p0: any, p1: any): any;
}
export class RegExp {
    static $1: any;
    static $2: any;
    static $3: any;
    static $4: any;
    static $5: any;
    static $6: any;
    static $7: any;
    static $8: any;
    static $9: any;
    static $_: any;
    static input: any;
    static lastMatch: any;
    static lastParen: any;
    static leftContext: any;
    static rightContext: any;
    constructor(p0: any, p1: any);
    // Native method; no parameter or return type inference available
    compile(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    exec(p0: any): any;
    // Native method; no parameter or return type inference available
    test(p0: any): any;
    // Native method; no parameter or return type inference available
    toString(): any;
}
export class Set {
    // Native method; no parameter or return type inference available
    add(p0: any): any;
    // Native method; no parameter or return type inference available
    clear(): any;
    // Native method; no parameter or return type inference available
    delete(p0: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    has(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class SharedArrayBuffer {
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
}
export class String {
    static fromCharCode(p0: any): any;
    static fromCodePoint(p0: any): any;
    static raw(p0: any): any;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    anchor(p0: any): any;
    // Native method; no parameter or return type inference available
    big(): any;
    // Native method; no parameter or return type inference available
    blink(): any;
    // Native method; no parameter or return type inference available
    bold(): any;
    // Native method; no parameter or return type inference available
    charAt(p0: any): any;
    // Native method; no parameter or return type inference available
    charCodeAt(p0: any): any;
    // Native method; no parameter or return type inference available
    codePointAt(p0: any): any;
    // Native method; no parameter or return type inference available
    concat(p0: any): any;
    // Native method; no parameter or return type inference available
    endsWith(p0: any): any;
    // Native method; no parameter or return type inference available
    fixed(): any;
    // Native method; no parameter or return type inference available
    fontcolor(p0: any): any;
    // Native method; no parameter or return type inference available
    fontsize(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    italics(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    link(p0: any): any;
    // Native method; no parameter or return type inference available
    localeCompare(p0: any): any;
    // Native method; no parameter or return type inference available
    match(p0: any): any;
    // Native method; no parameter or return type inference available
    normalize(): any;
    // Native method; no parameter or return type inference available
    padEnd(p0: any): any;
    // Native method; no parameter or return type inference available
    padStart(p0: any): any;
    // Native method; no parameter or return type inference available
    repeat(p0: any): any;
    // Native method; no parameter or return type inference available
    replace(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    search(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    small(): any;
    // Native method; no parameter or return type inference available
    split(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    startsWith(p0: any): any;
    // Native method; no parameter or return type inference available
    strike(): any;
    // Native method; no parameter or return type inference available
    sub(): any;
    // Native method; no parameter or return type inference available
    substr(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    substring(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    sup(): any;
    // Native method; no parameter or return type inference available
    toLocaleLowerCase(): any;
    // Native method; no parameter or return type inference available
    toLocaleUpperCase(): any;
    // Native method; no parameter or return type inference available
    toLowerCase(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    toUpperCase(): any;
    // Native method; no parameter or return type inference available
    trim(): any;
    // Native method; no parameter or return type inference available
    trimEnd(): any;
    // Native method; no parameter or return type inference available
    trimLeft(): any;
    // Native method; no parameter or return type inference available
    trimRight(): any;
    // Native method; no parameter or return type inference available
    trimStart(): any;
    // Native method; no parameter or return type inference available
    valueOf(): any;
}
export class Symbol {
    static asyncIterator: symbol;
    static hasInstance: symbol;
    static isConcatSpreadable: symbol;
    static iterator: symbol;
    static keyFor(p0: any): any;
    static match: symbol;
    static replace: symbol;
    static search: symbol;
    static species: symbol;
    static split: symbol;
    static toPrimitive: symbol;
    static toStringTag: symbol;
    static unscopables: symbol;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    valueOf(): any;
}
export class SyntaxError {
    static captureStackTrace(p0: any, p1: any): any;
    static prepareStackTrace(error: any, stack: any): any;
    static stackTraceLimit: number;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
}
export class TypeError {
    static captureStackTrace(p0: any, p1: any): any;
    static prepareStackTrace(error: any, stack: any): any;
    static stackTraceLimit: number;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
}
export class URIError {
    static captureStackTrace(p0: any, p1: any): any;
    static prepareStackTrace(error: any, stack: any): any;
    static stackTraceLimit: number;
    constructor(p0: any);
    // Native method; no parameter or return type inference available
    toString(): any;
}
export class URL {
    constructor(input: any, base: any);
    toJSON(): any;
    toString(): any;
}
export class URLSearchParams {
    constructor(init: any);
    append(name: any, value: any): void;
    delete(name: any): void;
    entries(): any;
    forEach(callback: any, thisArg: any): void;
    get(name: any): any;
    getAll(name: any): any;
    has(name: any): any;
    keys(): any;
    set(name: any, value: any): void;
    sort(): void;
    toString(): any;
    values(): any;
}
export class Uint16Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class Uint32Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class Uint8Array {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class Uint8ClampedArray {
    static BYTES_PER_ELEMENT: number;
    static from(p0: any): any;
    static of(): any;
    constructor(p0: any, p1: any, p2: any);
    // Native method; no parameter or return type inference available
    copyWithin(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    entries(): any;
    // Native method; no parameter or return type inference available
    every(p0: any): any;
    // Native method; no parameter or return type inference available
    fill(p0: any): any;
    // Native method; no parameter or return type inference available
    filter(p0: any): any;
    // Native method; no parameter or return type inference available
    find(p0: any): any;
    // Native method; no parameter or return type inference available
    findIndex(p0: any): any;
    // Native method; no parameter or return type inference available
    forEach(p0: any): any;
    // Native method; no parameter or return type inference available
    includes(p0: any): any;
    // Native method; no parameter or return type inference available
    indexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    join(p0: any): any;
    // Native method; no parameter or return type inference available
    keys(): any;
    // Native method; no parameter or return type inference available
    lastIndexOf(p0: any): any;
    // Native method; no parameter or return type inference available
    map(p0: any): any;
    // Native method; no parameter or return type inference available
    reduce(p0: any): any;
    // Native method; no parameter or return type inference available
    reduceRight(p0: any): any;
    // Native method; no parameter or return type inference available
    reverse(): any;
    // Native method; no parameter or return type inference available
    set(p0: any): any;
    // Native method; no parameter or return type inference available
    slice(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    some(p0: any): any;
    // Native method; no parameter or return type inference available
    sort(p0: any): any;
    // Native method; no parameter or return type inference available
    subarray(p0: any, p1: any): any;
    // Native method; no parameter or return type inference available
    toLocaleString(): any;
    // Native method; no parameter or return type inference available
    toString(): any;
    // Native method; no parameter or return type inference available
    values(): any;
}
export class WeakMap {
    // Native method; no parameter or return type inference available
    delete(p0: any): any;
    // Native method; no parameter or return type inference available
    get(p0: any): any;
    // Native method; no parameter or return type inference available
    has(p0: any): any;
    // Native method; no parameter or return type inference available
    set(p0: any, p1: any): any;
}
export class WeakSet {
    // Native method; no parameter or return type inference available
    add(p0: any): any;
    // Native method; no parameter or return type inference available
    delete(p0: any): any;
    // Native method; no parameter or return type inference available
    has(p0: any): any;
}
export namespace WebAssembly {
    class CompileError {
        static captureStackTrace(p0: any, p1: any): any;
        static prepareStackTrace(error: any, stack: any): any;
        static stackTraceLimit: number;
        constructor(p0: any);
        // Native method; no parameter or return type inference available
        toString(): any;
    }
    function Instance(p0: any): any;
    class LinkError {
        static captureStackTrace(p0: any, p1: any): any;
        static prepareStackTrace(error: any, stack: any): any;
        static stackTraceLimit: number;
        constructor(p0: any);
        // Native method; no parameter or return type inference available
        toString(): any;
    }
    class Memory {
        constructor(p0: any);
        // Native method; no parameter or return type inference available
        grow(p0: any): any;
    }
    function Module(p0: any): any;
    namespace Module {
        function customSections(p0: any, p1: any): any;
        function exports(p0: any): any;
        function imports(p0: any): any;
    }
    class RuntimeError {
        static captureStackTrace(p0: any, p1: any): any;
        static prepareStackTrace(error: any, stack: any): any;
        static stackTraceLimit: number;
        constructor(p0: any);
        // Native method; no parameter or return type inference available
        toString(): any;
    }
    class Table {
        constructor(p0: any);
        // Native method; no parameter or return type inference available
        get(p0: any): any;
        // Native method; no parameter or return type inference available
        grow(p0: any): any;
        // Native method; no parameter or return type inference available
        set(p0: any, p1: any): any;
    }
    function compile(p0: any): any;
    function instantiate(p0: any): any;
    function validate(p0: any): any;
}
export function after(name: any, fn: any): void;
export function afterEach(name: any, fn: any): void;
export function before(name: any, fn: any): void;
export function beforeEach(name: any, fn: any): void;
export function clearImmediate(immediate: any): void;
export function clearInterval(timer: any): void;
export function clearTimeout(timer: any): void;
export namespace console {
    class Console {
        constructor(options: any);
        assert(expression: any, args: any): void;
        clear(): void;
        count(label: any): void;
        countReset(label: any): void;
        debug(args: any): void;
        dir(object: any, options: any): void;
        dirxml(args: any): void;
        error(args: any): void;
        group(data: any): void;
        groupCollapsed(data: any): void;
        groupEnd(): void;
        info(args: any): void;
        log(args: any): void;
        table(tabularData: any, properties: any): any;
        time(label: any): void;
        timeEnd(label: any): void;
        trace(args: any): void;
        warn(args: any): void;
    }
    function assert(expression: any, args: any): void;
    function clear(): void;
    function context(p0: any): any;
    function count(): any;
    function countReset(label: any): void;
    function debug(): any;
    function dir(object: any, options: any): void;
    function dirxml(args: any): void;
    function error(args: any): void;
    function group(data: any): void;
    function groupCollapsed(): any;
    function groupEnd(): any;
    function info(args: any): void;
    function log(args: any): void;
    function markTimeline(p0: any): any;
    function profile(p0: any): any;
    function profileEnd(p0: any): any;
    function table(): any;
    function time(label: any): void;
    function timeEnd(): any;
    function timeStamp(p0: any): any;
    function timeline(p0: any): any;
    function timelineEnd(p0: any): any;
    function trace(): any;
    function warn(args: any): void;
}
export function context(title: any, fn: any): any;
export namespace context {
    function only(title: any, fn: any): any;
    function skip(title: any, fn: any): any;
}
export function decodeURI(p0: any): any;
export function decodeURIComponent(p0: any): any;
export function describe(title: any, fn: any): any;
export namespace describe {
    function only(title: any, fn: any): any;
    function skip(title: any, fn: any): any;
}
export function encodeURI(p0: any): any;
export function encodeURIComponent(p0: any): any;
export function escape(p0: any): any;
// Circular reference from example
export const global: any;
export function isFinite(p0: any): any;
export function isNaN(p0: any): any;
export function it(title: any, fn: any): any;
export namespace it {
    function only(title: any, fn: any): any;
    function retries(n: any): void;
    function skip(title: any): any;
}
export function parseFloat(p0: any): any;
export function parseInt(p0: any, p1: any): any;
export namespace process {
    function abort(): any;
    function addListener(type: any, listener: any): any;
    const arch: string;
    const argv: string[];
    const argv0: string;
    function assert(args: any): any;
    function binding(module: any): any;
    function chdir(args: any): any;
    const config: {
        target_defaults: {
            cflags: any[];
            default_configuration: string;
            defines: any[];
            include_dirs: any[];
            libraries: any[];
        };
        variables: {
            asan: number;
            build_v8_with_gn: boolean;
            coverage: boolean;
            debug_nghttp2: boolean;
            force_dynamic_crt: number;
            gas_version: string;
            host_arch: string;
            icu_data_in: string;
            icu_endianness: string;
            icu_gyp_path: string;
            icu_locales: string;
            icu_path: string;
            icu_small: boolean;
            icu_ver_major: string;
            llvm_version: number;
            node_byteorder: string;
            node_debug_lib: boolean;
            node_enable_d8: boolean;
            node_enable_v8_vtunejit: boolean;
            node_install_npm: boolean;
            node_module_version: number;
            node_no_browser_globals: boolean;
            node_prefix: string;
            node_release_urlbase: string;
            node_shared: boolean;
            node_shared_cares: boolean;
            node_shared_http_parser: boolean;
            node_shared_libuv: boolean;
            node_shared_nghttp2: boolean;
            node_shared_openssl: boolean;
            node_shared_zlib: boolean;
            node_tag: string;
            node_target_type: string;
            node_use_bundled_v8: boolean;
            node_use_dtrace: boolean;
            node_use_etw: boolean;
            node_use_openssl: boolean;
            node_use_perfctr: boolean;
            node_use_v8_platform: boolean;
            node_without_node_options: boolean;
            openssl_fips: string;
            openssl_no_asm: number;
            shlib_suffix: string;
            target_arch: string;
            v8_enable_gdbjit: number;
            v8_enable_i18n_support: number;
            v8_enable_inspector: number;
            v8_no_strict_aliasing: number;
            v8_optimized_debug: number;
            v8_promise_internal_field_count: number;
            v8_random_seed: number;
            v8_trace_maps: number;
            v8_typed_array_max_size_in_heap: number;
            v8_use_snapshot: boolean;
            want_separate_host_toolset: number;
        };
    };
    function cpuUsage(prevValue: any): any;
    function cwd(): any;
    const debugPort: number;
    function dlopen(): any;
    const domain: any;
    function emit(type: any, args: any): any;
    function emitWarning(warning: any, type: any, code: any, ctor: any, now: any): void;
    const env: {
        CINNAMON_VERSION: string;
        DBUS_SESSION_BUS_ADDRESS: string;
        DEFAULTS_PATH: string;
        DESKTOP_SESSION: string;
        DISPLAY: string;
        GDMSESSION: string;
        GDM_LANG: string;
        GJS_DEBUG_OUTPUT: string;
        GJS_DEBUG_TOPICS: string;
        GNOME_DESKTOP_SESSION_ID: string;
        GTK_MODULES: string;
        GTK_OVERLAY_SCROLLING: string;
        HOME: string;
        LANG: string;
        LANGUAGE: string;
        LESSCLOSE: string;
        LESSOPEN: string;
        LOADED_MOCHA_OPTS: string;
        LOGNAME: string;
        LS_COLORS: string;
        MANDATORY_PATH: string;
        NODE_ENV: string;
        NVM_BIN: string;
        NVM_CD_FLAGS: string;
        NVM_DIR: string;
        OLDPWD: string;
        PATH: string;
        PORT: string;
        PWD: string;
        QT_ACCESSIBILITY: string;
        QT_LINUX_ACCESSIBILITY_ALWAYS_ON: string;
        QT_QPA_PLATFORMTHEME: string;
        QT_STYLE_OVERRIDE: string;
        SESSION_MANAGER: string;
        SHELL: string;
        SHLVL: string;
        SSH_AGENT_PID: string;
        SSH_AUTH_SOCK: string;
        TERM: string;
        TSS_LOG: string;
        TYPES_PUBLISHER_CLIENT_ID: string;
        TYPES_PUBLISHER_CLIENT_SECRET: string;
        USER: string;
        VTE_VERSION: string;
        WINDOWID: string;
        XAUTHORITY: string;
        XDG_CONFIG_DIRS: string;
        XDG_CURRENT_DESKTOP: string;
        XDG_DATA_DIRS: string;
        XDG_GREETER_DATA_DIR: string;
        XDG_RUNTIME_DIR: string;
        XDG_SEAT: string;
        XDG_SEAT_PATH: string;
        XDG_SESSION_DESKTOP: string;
        XDG_SESSION_ID: string;
        XDG_SESSION_PATH: string;
        XDG_SESSION_TYPE: string;
        XDG_VTNR: string;
        lint: string;
        t: string;
    };
    function eventNames(): any;
    const execArgv: any[];
    const execPath: string;
    function exit(code: any): void;
    const features: {
        debug: boolean;
        ipv6: boolean;
        tls: boolean;
        tls_alpn: boolean;
        tls_ocsp: boolean;
        tls_sni: boolean;
        uv: boolean;
    };
    function getMaxListeners(): any;
    function getegid(): any;
    function geteuid(): any;
    function getgid(): any;
    function getgroups(): any;
    function getuid(): any;
    function hasUncaughtExceptionCaptureCallback(): any;
    function hrtime(time: any): any;
    function initgroups(args: any): any;
    function kill(pid: any, sig: any): any;
    function listenerCount(type: any): any;
    function listeners(type: any): any;
    namespace mainModule {
        const children: {
            children: any;
            exports: any;
            filename: any;
            id: any;
            load: any;
            loaded: any;
            parent: any;
            paths: any;
            require: any;
        }[];
        const exports: {};
        const filename: string;
        const id: string;
        class load {
            constructor(filename: any);
            filename: any;
            paths: any;
            loaded: any;
        }
        const loaded: boolean;
        const parent: any;
        const paths: string[];
        function require(id: any): any;
    }
    function memoryUsage(): any;
    const moduleLoadList: string[];
    function nextTick(callback: any): void;
    function off(type: any, listener: any): any;
    function on(type: any, listener: any): any;
    function once(type: any, listener: any): any;
    function openStdin(): any;
    const pid: number;
    const platform: string;
    const ppid: number;
    function prependListener(type: any, listener: any): any;
    function prependOnceListener(type: any, listener: any): any;
    function rawListeners(type: any): any;
    function reallyExit(): any;
    const release: {
        headersUrl: string;
        name: string;
        sourceUrl: string;
    };
    function removeAllListeners(type: any): any;
    function removeListener(type: any, listener: any): any;
    function setMaxListeners(n: any): any;
    function setUncaughtExceptionCaptureCallback(fn: any): void;
    function setegid(args: any): any;
    function seteuid(args: any): any;
    function setgid(args: any): any;
    function setgroups(args: any): any;
    function setuid(args: any): any;
    const stderr: any;
    const stdin: any;
    const stdout: any;
    const title: string;
    function umask(args: any): any;
    function uptime(): any;
    const version: string;
    const versions: {
        ares: string;
        cldr: string;
        http_parser: string;
        icu: string;
        modules: string;
        napi: string;
        nghttp2: string;
        node: string;
        openssl: string;
        tz: string;
        unicode: string;
        uv: string;
        v8: string;
        zlib: string;
    };
}
export const root: any;
export const run: any;
export function setImmediate(callback: any, arg1: any, arg2: any, arg3: any): any;
export function setInterval(callback: any, repeat: any, arg1: any, arg2: any, arg3: any): any;
export function setTimeout(callback: any, after: any, arg1: any, arg2: any, arg3: any): any;
export function specify(title: any, fn: any): any;
export namespace specify {
    function only(title: any, fn: any): any;
    function retries(n: any): void;
    function skip(title: any): any;
}
export const undefined: any;
export function unescape(p0: any): any;
export function xcontext(title: any, fn: any): any;
export function xdescribe(title: any, fn: any): any;
export function xit(title: any): any;
export function xspecify(title: any): any;